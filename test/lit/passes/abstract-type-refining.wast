;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.

;; RUN: foreach %s %t wasm-opt --abstract-type-refining --traps-never-happen -all --closed-world --nominal -S -o - | filecheck %s --check-prefix=YESTNH
;; RUN: foreach %s %t wasm-opt --abstract-type-refining                      -all --closed-world --nominal -S -o - | filecheck %s --check-prefix=NO_TNH

;; Run in both TNH and non-TNH mode.

;; $A :> $B :> $C :> $D :> $E
;;
;; $A and $D have no struct.news, so any operations on them must, in TNH mode,
;; actually refer to a subtype of them (that has a struct.new). As a result, in
;; TNH mode $A and $D will also not be emitted in the output anymore.
(module
  ;; NO_TNH:      (type $anyref_=>_none (func (param anyref)))

  ;; NO_TNH:      (type $A (struct ))
  (type $A (struct))

  ;; YESTNH:      (type $B (struct ))
  ;; NO_TNH:      (type $B (struct_subtype  $A))
  (type $B (struct_subtype $A))

  ;; YESTNH:      (type $anyref_=>_none (func (param anyref)))

  ;; YESTNH:      (type $C (struct_subtype  $B))
  ;; NO_TNH:      (type $C (struct_subtype  $B))
  (type $C (struct_subtype $B))

  ;; NO_TNH:      (type $D (struct_subtype  $C))
  (type $D (struct_subtype $C))

  ;; YESTNH:      (type $E (struct_subtype  $C))
  ;; NO_TNH:      (type $E (struct_subtype  $D))
  (type $E (struct_subtype $D))

  ;; YESTNH:      (type $none_=>_none (func))

  ;; YESTNH:      (global $global anyref (struct.new_default $B))
  ;; NO_TNH:      (type $none_=>_none (func))

  ;; NO_TNH:      (global $global anyref (struct.new_default $B))
  (global $global anyref (struct.new $B))

  ;; YESTNH:      (func $new (type $anyref_=>_none) (param $x anyref)
  ;; YESTNH-NEXT:  (drop
  ;; YESTNH-NEXT:   (struct.new_default $C)
  ;; YESTNH-NEXT:  )
  ;; YESTNH-NEXT:  (drop
  ;; YESTNH-NEXT:   (struct.new_default $E)
  ;; YESTNH-NEXT:  )
  ;; YESTNH-NEXT: )
  ;; NO_TNH:      (func $new (type $anyref_=>_none) (param $x anyref)
  ;; NO_TNH-NEXT:  (drop
  ;; NO_TNH-NEXT:   (struct.new_default $C)
  ;; NO_TNH-NEXT:  )
  ;; NO_TNH-NEXT:  (drop
  ;; NO_TNH-NEXT:   (struct.new_default $E)
  ;; NO_TNH-NEXT:  )
  ;; NO_TNH-NEXT: )
  (func $new (param $x anyref)
    (drop
      (struct.new $C)
    )
    (drop
      (struct.new $E)
    )
  )

  ;; YESTNH:      (func $ref.cast (type $anyref_=>_none) (param $x anyref)
  ;; YESTNH-NEXT:  (drop
  ;; YESTNH-NEXT:   (ref.cast $B
  ;; YESTNH-NEXT:    (local.get $x)
  ;; YESTNH-NEXT:   )
  ;; YESTNH-NEXT:  )
  ;; YESTNH-NEXT:  (drop
  ;; YESTNH-NEXT:   (ref.cast $B
  ;; YESTNH-NEXT:    (local.get $x)
  ;; YESTNH-NEXT:   )
  ;; YESTNH-NEXT:  )
  ;; YESTNH-NEXT:  (drop
  ;; YESTNH-NEXT:   (ref.cast $C
  ;; YESTNH-NEXT:    (local.get $x)
  ;; YESTNH-NEXT:   )
  ;; YESTNH-NEXT:  )
  ;; YESTNH-NEXT:  (drop
  ;; YESTNH-NEXT:   (ref.cast $E
  ;; YESTNH-NEXT:    (local.get $x)
  ;; YESTNH-NEXT:   )
  ;; YESTNH-NEXT:  )
  ;; YESTNH-NEXT:  (drop
  ;; YESTNH-NEXT:   (ref.cast $E
  ;; YESTNH-NEXT:    (local.get $x)
  ;; YESTNH-NEXT:   )
  ;; YESTNH-NEXT:  )
  ;; YESTNH-NEXT: )
  ;; NO_TNH:      (func $ref.cast (type $anyref_=>_none) (param $x anyref)
  ;; NO_TNH-NEXT:  (drop
  ;; NO_TNH-NEXT:   (ref.cast $A
  ;; NO_TNH-NEXT:    (local.get $x)
  ;; NO_TNH-NEXT:   )
  ;; NO_TNH-NEXT:  )
  ;; NO_TNH-NEXT:  (drop
  ;; NO_TNH-NEXT:   (ref.cast $B
  ;; NO_TNH-NEXT:    (local.get $x)
  ;; NO_TNH-NEXT:   )
  ;; NO_TNH-NEXT:  )
  ;; NO_TNH-NEXT:  (drop
  ;; NO_TNH-NEXT:   (ref.cast $C
  ;; NO_TNH-NEXT:    (local.get $x)
  ;; NO_TNH-NEXT:   )
  ;; NO_TNH-NEXT:  )
  ;; NO_TNH-NEXT:  (drop
  ;; NO_TNH-NEXT:   (ref.cast $D
  ;; NO_TNH-NEXT:    (local.get $x)
  ;; NO_TNH-NEXT:   )
  ;; NO_TNH-NEXT:  )
  ;; NO_TNH-NEXT:  (drop
  ;; NO_TNH-NEXT:   (ref.cast $E
  ;; NO_TNH-NEXT:    (local.get $x)
  ;; NO_TNH-NEXT:   )
  ;; NO_TNH-NEXT:  )
  ;; NO_TNH-NEXT: )
  (func $ref.cast (param $x anyref)
    ;; List out all possible casts for comprehensiveness. For other instructions
    ;; we are more focused, below.
    (drop
      (ref.cast $A     ;; This will be $B in TNH.
        (local.get $x)
      )
    )
    (drop
      (ref.cast $B
        (local.get $x)
      )
    )
    (drop
      (ref.cast $C
    