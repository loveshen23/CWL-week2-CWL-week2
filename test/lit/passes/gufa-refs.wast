;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; RUN: foreach %s %t wasm-opt -all --gufa --nominal -S -o - | filecheck %s

(module
  ;; CHECK:      (type $struct (struct ))
  (type $struct (struct))


  ;; CHECK:      (type $none_=>_none (func))

  ;; CHECK:      (type $none_=>_ref|$struct| (func (result (ref $struct))))

  ;; CHECK:      (type $none_=>_i32 (func (result i32)))

  ;; CHECK:      (type $none_=>_ref|any| (func (result (ref any))))

  ;; CHECK:      (import "a" "b" (func $import (result i32)))
  (import "a" "b" (func $import (result i32)))

  ;; CHECK:      (func $no-non-null (type $none_=>_ref|any|) (result (ref any))
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $no-non-null (result (ref any))
    ;; The only possible value at the location of this ref.as_non_null is a
    ;; null - but that value does not have a compatible type (null is nullable).
    ;; Therefore we can infer that nothing is possible here, and the code must
    ;; trap, and we'll optimize this to an unreachable.
    (ref.as_non_null
      (ref.null any)
    )
  )

  ;; CHECK:      (func $nested (type $none_=>_i32) (result i32)
  ;; CHECK-NEXT:  (ref.is_null
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (loop $loop
  ;; CHECK-NEXT:      (block
  ;; CHECK-NEXT:       (unreachable)
  ;; CHECK-NEXT:       (unreachable)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (unreachable)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $nested (result i32)
    ;; As above, but add other instructions on the outside, which can also be
    ;; replaced with an unreachable (except for the loop, which as a control
    ;; flow structure with a name we keep it around and just add an unreachable
    ;; after it; and for now we don't optimize ref.is* so that stays).
    (ref.is_null
      (loop $loop (result (ref func))
        (nop)
        (ref.as_func
          (ref.as_non_null
            (ref.null func)
          )
        )
      )
    )
  )

  ;; CHECK:      (func $yes-non-null (type $none_=>_ref|any|) (result (ref any))
  ;; CHECK-NEXT:  (ref.as_non_null
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $yes-non-null (result (ref any))
    ;; Similar to the above but now there *is* an non-null value here, so there
    ;; is nothing for us to optimize or change here.
    (ref.as_non_null
      (struct.new $struct)
    )
  )

  ;; CHECK:      (func $breaks (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block $block (result (ref $struct))
  ;; CHECK-NEXT:    (br $block
  ;; CHECK-NEXT:     (struct.new_default $struct)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $breaks
    ;; Check that we notice values sent along breaks. We should optimize
    ;; nothing in the first block here.
    (drop
      (block $block (result (ref any))
        (br $block
          (struct.new $struct)
        )
      )
    )
    ;; But here we send a null so we can optimize to an unreachable.
    (drop
      (ref.as_non_null
        (block $block2 (result (ref null any))
          (br $block2
            (ref.null $struct)
          )
        )
      )
    )
  )

  ;; CHECK:      (func $get-nothing (type $none_=>_ref|$struct|) (result (ref $struct))
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $get-nothing (result (ref $struct))
    ;; This function returns a non-nullable struct by type, but does not
    ;; actually return a value in practice, and our whole-program analysis
    ;; should pick that up in optimizing the callers (but nothing changes here).
    (unreachable)
  )

  ;; CHECK:      (func $get-nothing-calls (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (call $get-nothing)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (block
  ;; CHECK-NEXT:     (drop
  ;; CHECK-NEXT:      (call $get-nothing)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.is_null
  ;; CHECK-NEXT:    (block
  ;; CHECK-NEXT:     (drop
  ;; CHECK-NEXT:      (call $get-nothing)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get-nothing-calls
    ;; This can be optimized since the call does not actually return any
    ;; possible content (it has an unreachable), which means we can optimize
    ;; away the call's value - we must keep it around in a drop, since it can
    ;; have side effects, but the drop ignores the value which we do not need.
    (drop
      (call $get-nothing)
    )
    ;; As above, add another instruction in the middle. We can optimize it to
    ;; an unreachable, like the call.
    (drop
      (ref.as_non_null
        (call $get-nothing)
      )
    )
    ;; As above, but we do not optimize ref.is_null yet so nothing happens for
    ;; it (but the call still gets optimized as before).
    (drop
      (ref.is_null
        (call $get-nothing)
      )
    )
  )

  ;; CHECK:      (func $two-inputs (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (select
  ;; CHECK-NEXT:    (struct.new_default $struct)
  ;; CHECK-NEXT:    (block
  ;; CHECK-NEXT:     (drop
  ;; CHECK-NEXT:      (call $get-nothing)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (select
  ;; CHECK-NEXT:    (block
  ;; CHECK-NEXT:     (drop
  ;; CHECK-NEXT:      (call $get-nothing)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (struct.new_default $struct)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (select (result (ref $struct))
  ;; CHECK-NEXT:    (struct.new_default $struct)
  ;; CHECK-NEXT:    (struct.new_default $struct)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (block
  ;; CHECK-NEXT:     (drop
  ;; CHECK-NEXT:      (call $get-nothing)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (block
  ;; CHECK-NEXT:     (drop
  ;; CHECK-NEXT:      (call $get-nothing)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $two-inputs
    ;; As above, but now the outer instruction is a select, and some of the arms
    ;; may have a possible type - we check all 4 permutations. Only in the
    ;; case where both inputs are nothing can we optimize away the select (that
    ;; is, drop it and ignore its value), as only then will the select never
    ;; have any contents.
    ;; (Note: we are not fully optimal here since we could notice that the
    ;; select executes both arms unconditionally, so if one traps then it will
    ;; all trap.)
    (drop
      (select (result (ref any))
        (struct.new $struct)
        (call $get-nothing)
        (call $import)
      )
    )
    (drop
      (select (result (ref any))
        (call $get-nothing)
        (struct.new $struct)
        (call $import)
      )
    )
    (drop
      (select (result (ref any))
        (struct.new $struct)
        (struct.new $struct)
        (call $import)
      )
    )
    (drop
      (select (result (ref any))
        (call $get-nothing)
        (call $get-nothing)
        (call $import)
      )
    )
  )

  ;; CHECK:      (func $get-something-flow (type $none_=>_ref|$struct|) (result (ref $struct))
  ;; CHECK-NEXT:  (struct.new_default $struct)
  ;; CHECK-NEXT: )
  (func $get-something-flow (result (ref $struct))
    ;; Return a value by flowing it out. Helper for later code.
    (struct.new $struct)
  )

  ;; CHECK:      (func $get-something-return (type $none_=>_ref|$struct|) (result (ref $struct))
  ;; CHECK-NEXT:  (return
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get-something-return (result (ref $struct))
    ;; Return a value using an explicit return. Helper for later code.
    (return
      (struct.new $struct)
    )
  )

  ;; CHECK:      (func $call-get-something (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (call $get-something-flow)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (call $get-something-return)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $call-get-something
    ;; In both of these cases a value is actually returned and there is nothing
    ;; to optimize, unlike get-nothing from above.
    (drop
      (call $get-something-flow)
    )
    (drop
      (call $get-something-return)
    )
  )

  ;; CHECK:      (func $locals (type $none_=>_none)
  ;; CHECK-NEXT:  (local $x anyref)
  ;; CHECK-NEXT:  (local $y anyref)
  ;; CHECK-NEXT:  (local $z anyref)
  ;; CHECK-NEXT:  (local.tee $x
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (call $get-nothing)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $z
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.null none)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $z)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $locals
    (local $x (ref null any))
    (local $y (ref null any))
    (local $z (ref null any))
    ;; Assign to x from a call that actually will not return anything. We will
    ;; be able to optimize away the call's return value (drop it) and append an
    ;; unreachable.
    (local.set $x
      (call $get-nothing)
    )
    ;; Never assign to y.
    ;; Assign to z an actual value.
    (local.set $z
      (struct.new $struct)
    )
    ;; Get the 3 locals, to check that we optimize. We can replace x with an
    ;; unreachable and y with a null constant.
    (drop
      (local.get $x)
    )
    (drop
      (local.get $y)
    )
    (drop
      (local.get $z)
    )
  )
)

(module
  ;; CHECK:      (type $struct (struct ))
  (type $struct (struct))

  ;; CHECK:      (type $none_=>_none (func))

  ;; CHECK:      (global $null anyref (ref.null none))
  (global $null (ref null any) (ref.null any))
  ;; CHECK:      (global $something anyref (struct.new_default $struct))
  (global $something (ref null any) (struct.new $struct))

  ;; CHECK:      (global $mut-null (mut anyref) (ref.null none))
  (global $mut-null (mut (ref null any)) (ref.null any))
  ;; CHECK:      (global $mut-something (mut anyref) (ref.null none))
  (global $mut-something (mut (ref null any)) (ref.null any))

  ;; CHECK:      (func $read-globals (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.null none)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (global.get $something)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (global.get $mut-something)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $read-globals
    ;; This global has no possible contents aside from a null, which we can
    ;; infer and place here.
    (drop
      (global.get $null)
    )
    ;; This global has no possible contents aside from a null, so the
    ;; ref.as_non_null can be optimized to an unreachable (since a null is not
    ;; compatible with its non-nullable type).
    (drop
      (ref.as_non_null
        (global.get $null)
      )
    )
    ;; This global has a possible non-null value (in the initializer), so there
    ;; is nothing to do.
    (drop
      (ref.as_non_null
        (global.get $something)
      )
    )
    ;; This mutable global has a write aside from the initializer, but it is
    ;; also of a null, so we can optimize here.
    (drop
      (ref.as_non_null
        (global.get $mut-null)
      )
    )
    ;; This one also has a later write, of a non-null value, so there is nothing
    ;; to do.
    (drop
      (ref.as_non_null
        (global.get $mut-something)
      )
    )
  )

  ;; CHECK:      (func $write-globals (type $none_=>_none)
  ;; CHECK-NEXT:  (global.set $mut-null
  ;; CHECK-NEXT:   (ref.null none)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (global.set $mut-something
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $write-globals
    (global.set $mut-null
      (ref.null $struct)
    )
    (global.set $mut-something
      (struct.new $struct)
    )
  )
)

;; As above, but now with a chain of globals: A starts with a value, which is
;; copied to B, and then C, and then C is read. We will be able to optimize
;; away *-null (which is where A-null starts with null) but not *-something
;; (which is where A-something starts with a value).
(module
  ;; CHECK:      (type $none_=>_none (func))

  ;; CHECK:      (type $struct (struct ))
  (type $struct (struct))

  ;; CHECK:      (global $A-null anyref (ref.null none))
  (global $A-null (ref null any) (ref.null any))
  ;; CHECK:      (global $A-something anyref (struct.new_default $struct))
  (global $A-something (ref null any) (struct.new $struct))

  ;; CHECK:      (global $B-null (mut anyref) (ref.null none))
  (global $B-null (mut (ref null any)) (ref.null any))
  ;; CHECK:      (global $B-something (mut anyref) (ref.null none))
  (global $B-something (mut (ref null any)) (ref.null any))

  ;; CHECK:      (global $C-null (mut anyref) (ref.null none))
  (global $C-null (mut (ref null any)) (ref.null any))
  ;; CHECK:      (global $C-something (mut anyref) (ref.null none))
  (global $C-something (mut (ref null any)) (ref.null any))

  ;; CHECK:      (func $read-globals (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (global.get $A-something)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (global.get $B-something)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (global.get $C-something)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $read-globals
    (drop
      (ref.as_non_null
        (global.get $A-null)
      )
    )
    (drop
      (ref.as_non_null
        (global.get $A-something)
      )
    )
    (drop
      (ref.as_non_null
        (global.get $B-null)
      )
    )
    (drop
      (ref.as_non_null
        (global.get $B-something)
      )
    )
    (drop
      (ref.as_non_null
        (global.get $C-null)
      )
    )
    (drop
      (ref.as_non_null
        (global.get $C-something)
      )
    )
  )

  ;; CHECK:      (func $write-globals (type $none_=>_none)
  ;; CHECK-NEXT:  (global.set $B-null
  ;; CHECK-NEXT:   (ref.null none)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (global.set $C-null
  ;; CHECK-NEXT:   (ref.null none)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (global.set $B-something
  ;; CHECK-NEXT:   (global.get $A-something)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (global.set $C-something
  ;; CHECK-NEXT:   (global.get $B-something)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $write-globals
    (global.set $B-null
      (global.get $A-null)
    )
    (global.set $C-null
      (global.get $B-null)
    )
    (global.set $B-something
      (global.get $A-something)
    )
    (global.set $C-something
      (global.get $B-something)
    )
  )
)

(module
  ;; CHECK:      (type $ref|any|_=>_ref|any| (func (param (ref any)) (result (ref any))))

  ;; CHECK:      (type $struct (struct ))
  (type $struct (struct))

  ;; CHECK:      (type $i32_=>_i32 (func (param i32) (result i32)))

  ;; CHECK:      (type $ref|any|_ref|any|_ref|any|_=>_none (func (param (ref any) (ref any) (ref any))))

  ;; CHECK:      (type $none_=>_none (func))

  ;; CHECK:      (func $never-called (type $i32_=>_i32) (param $x i32) (result i32)
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $never-called (param $x i32) (result i32)
    ;; This function is never called, so the parameter has no possible contents,
    ;; and we can optimize to an unreachable.
    (local.get $x)
  )

  ;; CHECK:      (func $never-called-ref (type $ref|any|_=>_ref|any|) (param $x (ref any)) (result (ref any))
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $never-called-ref (param $x (ref any)) (result (ref any))
    ;; As above but with a reference type. Again, we can apply an unreachable.
    (local.get $x)
  )

  ;; CHECK:      (func $recursion (type $ref|any|_=>_ref|any|) (param $x (ref any)) (result (ref any))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (call $recursion
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $recursion (param $x (ref any)) (result (ref any))
    ;; This function calls itself recursively. That forms a loop, but still,
    ;; nothing reaches here, so we can optimize to an unreachable (we cannot
    ;; remove the call though, as it has effects, so we drop it).
    (call $recursion
      (local.get $x)
    )
  )

  ;; CHECK:      (func $called (type $ref|any|_ref|any|_ref|any|_=>_none) (param $x (ref any)) (param $y (ref any)) (param $z (ref any))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $z)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $called (param $x (ref any)) (param $y (ref any)) (param $z (ref any))
    ;; This function is called, with possible (non-null) values in the 1st & 3rd
    ;; params, but nothing can arrive in the 2nd, which we can optimize to an
    ;; unreachable.
    (drop
      (local.get $x)
    )
    (drop
      (local.get $y)
    )
    (drop
      (local.get $z)
    )
  )

  ;; CHECK:      (func $call-called (type $none_=>_none)
  ;; CHECK-NEXT:  (call $called
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $called
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $call-called
    ;; Call the above function as described there: Nothing can arrive in the
    ;; second param (since we cast a null to non-null there), while the others
    ;; have both a null and a non-null (different in the 2 calls here). (With
    ;; more precise analysis we could see that the ref.as must trap, and we
    ;; could optimize even more here.)
    (call $called
      (struct.new $struct)
      (ref.as_non_null
        (ref.null any)
      )
      (ref.as_non_null
        (ref.null any)
      )
    )
    (call $called
      (ref.as_non_null
        (ref.null any)
      )
      (ref.as_non_null
        (ref.null any)
      )
      (struct.new $struct)
    )
  )
)

;; As above, but using indirect calls.
(module
  ;; CHECK:      (type $struct (struct ))

  ;; CHECK:      (type $two-params (func (param (ref $struct) (ref $struct))))
  (type $two-params (func (param (ref $struct)) (param (ref $struct))))

  ;; CHECK:      (type $three-params (func (param (ref $struct) (ref $struct) (ref $struct))))
  (type $three-params (func (param (ref $struct)) (param (ref $struct)) (param (ref $struct))))

  (type $struct (struct))

  (table 10 funcref)

  (elem (i32.const 0) funcref
    (ref.func $func-2params-a)
    (ref.func $func-2params-b)
    (ref.func $func-3params)
  )

  ;; CHECK:      (table $0 10 funcref)

  ;; CHECK:      (elem (i32.const 0) $func-2params-a $func-2params-b $func-3params)

  ;; CHECK:      (func $func-2params-a (type $two-params) (param $x (ref $struct)) (param $y (ref $struct))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $y)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call_indirect $0 (type $two-params)
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:   (i32.const 0)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func-2params-a (type $two-params) (param $x (ref $struct)) (param $y (ref $struct))
    ;; Only null is possible for the first, so we can optimize it to an
    ;; unreachable.
    (drop
      (local.get $x)
    )
    (drop
      (local.get $y)
    )
    ;; Send a value only to the second param.
    (call_indirect (type $two-params)
      (ref.as_non_null
        (ref.null $struct)
      )
      (struct.new $struct)
      (i32.const 0)
    )
  )

  ;; CHECK:      (func $func-2params-b (type $two-params) (param $x (ref $struct)) (param $y (ref $struct))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $y)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func-2params-b (type $two-params) (param $x (ref $struct)) (param $y (ref $struct))
    ;; Another function with the same signature as before, which we should
    ;; optimize in the same way: the indirect call can go to either.
    (drop
      (local.get $x)
    )
    (drop
      (local.get $y)
    )
  )

  ;; CHECK:      (func $func-3params (type $three-params) (param $x (ref $struct)) (param $y (ref $struct)) (param $z (ref $struct))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $z)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call_indirect $0 (type $three-params)
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:   (i32.const 0)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call_indirect $0 (type $three-params)
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:   (i32.const 0)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func-3params (type $three-params) (param $x (ref $struct)) (param $y (ref $struct)) (param $z (ref $struct))
    (drop
      (local.get $x)
    )
    (drop
      (local.get $y)
    )
    (drop
      (local.get $z)
    )
    ;; Send a non-null value only to the first and third param. Do so in two
    ;; separate calls. The second param, $y, can be optimized.
    (call_indirect (type $three-params)
      (struct.new $struct)
      (ref.as_non_null
        (ref.null $struct)
      )
      (ref.as_non_null
        (ref.null $struct)
      )
      (i32.const 0)
    )
    (call_indirect (type $three-params)
      (ref.as_non_null
        (ref.null $struct)
      )
      (ref.as_non_null
        (ref.null $struct)
      )
      (struct.new $struct)
      (i32.const 0)
    )
  )
)

;; As above, but using call_ref.
(module
  ;; CHECK:      (type $struct (struct ))

  ;; CHECK:      (type $two-params (func (param (ref $struct) (ref $struct))))
  (type $two-params (func (param (ref $struct)) (param (ref $struct))))

  (type $struct (struct))

  ;; CHECK:      (elem declare func $func-2params-a)

  ;; CHECK:      (func $func-2params-a (type $two-params) (param $x (ref $struct)) (param $y (ref $struct))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $y)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call_ref $two-params
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:   (ref.func $func-2params-a)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func-2params-a (type $two-params) (param $x (ref $struct)) (param $y (ref $struct))
    (drop
      (local.get $x)
    )
    (drop
      (local.get $y)
    )
    ;; Send a non-null value only to the second param.
    (call_ref $two-params
      (ref.as_non_null
        (ref.null $struct)
      )
      (struct.new $struct)
      (ref.func $func-2params-a)
    )
  )
)

;; Array creation.
(module
  ;; CHECK:      (type $vector (array (mut f64)))
  (type $vector (array (mut f64)))

  ;; CHECK:      (type $none_=>_none (func))

  ;; CHECK:      (func $arrays (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (array.new $vector
  ;; CHECK-NEXT:     (f64.const 3.14159)
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (array.new_default $vector
  ;; CHECK-NEXT:     (i32.const 100)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (array.new_fixed $vector
  ;; CHECK-NEXT:     (f64.const 1.1)
  ;; CHECK-NEXT:     (f64.const 2.2)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $arrays
    (drop
      (ref.as_non_null
        (array.new $vector
          (f64.const 3.14159)
          (i32.const 1)
        )
      )
    )
    (drop
      (ref.as_non_null
        (array.new_default $vector
          (i32.const 100)
        )
      )
    )
    (drop
      (ref.as_non_null
        (array.new_fixed $vector
          (f64.const 1.1)
          (f64.const 2.2)
        )
      )
    )
    ;; In the last case we have no possible non-null value and can optimize to
    ;; an unreachable.
    (drop
      (ref.as_non_null
        (ref.null $vector)
      )
    )
  )
)

;; Struct fields.
(module
  ;; CHECK:      (type $parent (struct (field (mut (ref null $struct)))))

  ;; CHECK:      (type $child (struct_subtype (field (mut (ref null $struct))) (field (mut (ref null $struct))) $parent))

  ;; CHECK:      (type $struct (struct ))
  (type $struct (struct_subtype data))

  (type $parent (struct_subtype (field (mut (ref null $struct))) data))
  (type $child (struct_subtype (field (mut (ref null $struct))) (field (mut (ref null $struct))) $parent))

  ;; CHECK:      (type $none_=>_none (func))

  ;; CHECK:      (type $unrelated (struct ))
  (type $unrelated (struct))

  ;; CHECK:      (func $func (type $none_=>_none)
  ;; CHECK-NEXT:  (local $child (ref null $child))
  ;; CHECK-NEXT:  (local $parent (ref null $parent))
  ;; CHECK-NEXT:  (local.set $child
  ;; CHECK-NEXT:   (struct.new $child
  ;; CHECK-NEXT:    (struct.new_default $struct)
  ;; CHECK-NEXT:    (ref.null none)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $child 0
  ;; CHECK-NEXT:    (local.get $child)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result nullref)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $child 1
  ;; CHECK-NEXT:      (local.get $child)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (ref.null none)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $parent
  ;; CHECK-NEXT:   (struct.new $parent
  ;; CHECK-NEXT:    (ref.null none)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result nullref)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $parent 0
  ;; CHECK-NEXT:      (local.get $parent)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (ref.null none)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (block
  ;; CHECK-NEXT:     (drop
  ;; CHECK-NEXT:      (block $parent (result (ref $parent))
  ;; CHECK-NEXT:       (drop
  ;; CHECK-NEXT:        (br_on_cast $parent $parent
  ;; CHECK-NEXT:         (struct.new_default $unrelated)
  ;; CHECK-NEXT:        )
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:       (unreachable)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func
    (local $child (ref null $child))
    (local $parent (ref null $parent))
    ;; We create a child with a non-null value in field 0 and null in 1.
    (local.set $child
      (struct.new $child
        (struct.new $struct)
        (ref.null $struct)
      )
    )
    ;; Getting field 0 should not be optimized or changed in any way.
    (drop
      (struct.get $child 0
        (local.get $child)
      )
    )
    ;; Field one can be optimized into a null constant (+ a drop of the get).
    (drop
      (struct.get $child 1
        (local.get $child)
      )
    )
    ;; Create a parent with a null. The child wrote to the shared field, but
    ;; using exact type info we can infer that the get's value must be a null,
    ;; so we can optimize.
    (local.set $parent
      (struct.new $parent
        (ref.null $struct)
      )
    )
    (drop
      (struct.get $parent 0
        (local.get $parent)
      )
    )
    ;; An unrelated type is cast to a struct type, and then we read from that.
    ;; The cast will trap at runtime, of course; for here, we should not error
    ;; and also we can optimize these to unreachables. atm we filter out
    ;; trapping contents in ref.cast, but not br_on_cast, so test both.
    (drop
      (struct.get $parent 0
        (ref.cast $parent
          (struct.new $unrelated)
        )
      )
    )
    (drop
      (struct.get $parent 0
        (block $parent (result (ref $parent))
          (drop
            (br_on_cast $parent $parent
              (struct.new $unrelated)
            )
          )
          (unreachable)
        )
      )
    )
  )

  ;; CHECK:      (func $nulls (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.null none)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result nullref)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block $block (result nullref)
  ;; CHECK-NEXT:      (br $block
  ;; CHECK-NEXT:       (ref.null none)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (unreachable)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (ref.null none)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result nullref)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block $block0 (result nullref)
  ;; CHECK-NEXT:      (br $block0
  ;; CHECK-NEXT:       (ref.null none)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (unreachable)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (ref.null none)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result nullref)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block $block1 (result nullref)
  ;; CHECK-NEXT:      (br $block1
  ;; CHECK-NEXT:       (block (result nullref)
  ;; CHECK-NEXT:        (drop
  ;; CHECK-NEXT:         (ref.cast null $child
  ;; CHECK-NEXT:          (ref.null none)
  ;; CHECK-NEXT:         )
  ;; CHECK-NEXT:        )
  ;; CHECK-NEXT:        (ref.null none)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (unreachable)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (ref.null none)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $nulls
    ;; Leave null constants alone.
    (drop
      (ref.null $parent)
    )
    ;; Reading from a null reference is easy to optimize - it will trap.
    (drop
      (struct.get $parent 0
        (ref.null $parent)
      )
    )
    ;; Send a null to the block, which is the only value exiting, so we can
    ;; optimize here.
    (drop
      (block $block (result (ref null any))
        (br $block
          (ref.null any)
        )
        (unreachable)
      )
    )
    ;; Send a more specific type. We should emit a valid null constant (but in
    ;; this case, a null of either $parent or $child would be ok).
    (drop
      (block $block (result (ref null $parent))
        (br $block
          (ref.null $child)
        )
        (unreachable)
      )
    )
    ;; Send a less specific type, via a cast. But all nulls are identical and
    ;; ref.cast null passes nulls through, so this is ok, but we must be careful to
    ;; emit a ref.null $child on the outside (to not change the outer type to a
    ;; less refined one).
    (drop
      (block $block (result (ref null $child))
        (br $block
          (ref.cast null $child
            (ref.null $parent)
          )
        )
        (unreachable)
      )
    )
  )
)

;; Default values in struct fields.
(module
  (type $A (struct_subtype (field i32) data))
  (type $B (struct_subtype (field i32) data))
  (type $C (struct_subtype (field i32) data))

  ;; CHECK:      (type $none_=>_none (func))

  ;; CHECK:      (func $func (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 0)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func
    ;; Create a struct with default values. We can propagate a 0 to the get.
    (drop
      (struct.get $A 0
        (struct.new_default $A)
      )
    )
    ;; Allocate with a non-default value, that can also be propagated.
    (drop
      (struct.get $B 0
        (struct.new $B
          (i32.const 1)
        )
      )
    )
  )
)

;; Exact types: Writes to the parent class do not confuse us.
(module
  ;; CHECK:      (type $parent (struct (field (mut (ref null $struct)))))

  ;; CHECK:      (type $child (struct_subtype (field (mut (ref null $struct))) (field i32) $parent))

  ;; CHECK:      (type $struct (struct ))
  (type $struct (struct_subtype data))
  (type $parent (struct_subtype (field (mut (ref null $struct))) data))
  (type $child (struct_subtype (field (mut (ref null $struct))) (field i32) $parent))

  ;; CHECK:      (type $none_=>_none (func))

  ;; CHECK:      (func $func (type $none_=>_none)
  ;; CHECK-NEXT:  (local $child (ref null $child))
  ;; CHECK-NEXT:  (local $parent (ref null $parent))
  ;; CHECK-NEXT:  (local.set $parent
  ;; CHECK-NEXT:   (struct.new $parent
  ;; CHECK-NEXT:    (struct.new_default $struct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (struct.get $parent 0
  ;; CHECK-NEXT:     (local.get $parent)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $child
  ;; CHECK-NEXT:   (struct.new $child
  ;; CHECK-NEXT:    (ref.null none)
  ;; CHECK-NEXT:    (i32.const 0)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block (result nullref)
  ;; CHECK-NEXT:      (drop
  ;; CHECK-NEXT:       (struct.get $child 0
  ;; CHECK-NEXT:        (local.get $child)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (ref.null none)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func
    (local $child (ref null $child))
    (local $parent (ref null $parent))
    ;; Allocate when writing to the parent's field.
    (local.set $parent
      (struct.new $parent
        (struct.new $struct)
      )
    )
    ;; This cannot be optimized in any way.
    (drop
      (ref.as_non_null
        (struct.get $parent 0
          (local.get $parent)
        )
      )
    )
    ;; The child writes a null to the first field.
    (local.set $child
      (struct.new $child
        (ref.null $struct)
        (i32.const 0)
      )
    )
    ;; The parent wrote to the shared field, but that does not prevent us from
    ;; seeing that the child must have a null there, and so this will trap.
    (drop
      (ref.as_non_null
        (struct.get $child 0
          (local.get $child)
        )
      )
    )
  )
)

;; Write values to the parent *and* the child and read from the child.
(module
  ;; CHECK:      (type $parent (struct (field (mut i32))))
  (type $parent (struct_subtype (field (mut i32)) data))
  ;; CHECK:      (type $child (struct_subtype (field (mut i32)) (field i32) $parent))
  (type $child (struct_subtype (field (mut i32)) (field i32) $parent))

  ;; CHECK:      (type $none_=>_none (func))

  ;; CHECK:      (func $func (type $none_=>_none)
  ;; CHECK-NEXT:  (local $child (ref null $child))
  ;; CHECK-NEXT:  (local $parent (ref null $parent))
  ;; CHECK-NEXT:  (local.set $parent
  ;; CHECK-NEXT:   (struct.new $parent
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $parent 0
  ;; CHECK-NEXT:      (local.get $parent)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $child
  ;; CHECK-NEXT:   (struct.new $child
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 30)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $child 0
  ;; CHECK-NEXT:      (local.get $child)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $child 1
  ;; CHECK-NEXT:      (local.get $child)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 30)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func
    (local $child (ref null $child))
    (local $parent (ref null $parent))
    (local.set $parent
      (struct.new $parent
        (i32.const 10)
      )
    )
    ;; This can be optimized to 10. The child also sets this field, but the
    ;; reference in the local $parent can only be a $parent and nothing else.
    (drop
      (struct.get $parent 0
        (local.get $parent)
      )
    )
    (local.set $child
      (struct.new $child
        ;; The value here conflicts with the parent's for this field, but the
        ;; local $child can only contain a $child and nothing else, so we can
        ;; optimize the get below us.
        (i32.const 20)
        (i32.const 30)
      )
    )
    (drop
      (struct.get $child 0
        (local.get $child)
      )
    )
    ;; This get aliases nothing but 30, so we can optimize.
    (drop
      (struct.get $child 1
        (local.get $child)
      )
    )
  )
)

;; As above, but the $parent local can now contain a child too.
(module
  ;; CHECK:      (type $parent (struct (field (mut i32))))
  (type $parent (struct_subtype (field (mut i32)) data))
  ;; CHECK:      (type $child (struct_subtype (field (mut i32)) (field i32) $parent))
  (type $child (struct_subtype (field (mut i32)) (field i32) $parent))

  ;; CHECK:      (type $i32_=>_none (func (param i32)))

  ;; CHECK:      (export "func" (func $func))

  ;; CHECK:      (func $func (type $i32_=>_none) (param $x i32)
  ;; CHECK-NEXT:  (local $child (ref null $child))
  ;; CHECK-NEXT:  (local $parent (ref null $parent))
  ;; CHECK-NEXT:  (local.set $parent
  ;; CHECK-NEXT:   (struct.new $parent
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.set $parent
  ;; CHECK-NEXT:    (local.tee $child
  ;; CHECK-NEXT:     (struct.new $child
  ;; CHECK-NEXT:      (i32.const 20)
  ;; CHECK-NEXT:      (i32.const 30)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $parent 0
  ;; CHECK-NEXT:    (local.get $parent)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $child 0
  ;; CHECK-NEXT:      (local.get $child)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func (export "func") (param $x i32)
    (local $child (ref null $child))
    (local $parent (ref null $parent))
    (local.set $parent
      (struct.new $parent
        (i32.const 10)
      )
    )
    ;; Another, optional, set to $parent.
    (if
      (local.get $x)
      (local.set $parent
        (local.tee $child
          (struct.new $child
            (i32.const 20)
            (i32.const 30)
          )
        )
      )
    )
    ;; This get cannot be optimized because before us the local might be set a
    ;; child as well. So the local $parent can refer to either type, and they
    ;; disagree on the aliased value.
    (drop
      (struct.get $parent 0
        (local.get $parent)
      )
    )
    ;; But this one can be optimized as $child can only contain a child.
    (drop
      (struct.get $child 0
        (local.get $child)
      )
    )
  )
)

;; As above, but now the parent and child happen to agree on the aliased value.
(module
  ;; CHECK:      (type $parent (struct (field (mut i32))))
  (type $parent (struct_subtype (field (mut i32)) data))
  ;; CHECK:      (type $child (struct_subtype (field (mut i32)) (field i32) $parent))
  (type $child (struct_subtype (field (mut i32)) (field i32) $parent))

  ;; CHECK:      (type $none_=>_none (func))

  ;; CHECK:      (func $func (type $none_=>_none)
  ;; CHECK-NEXT:  (local $child (ref null $child))
  ;; CHECK-NEXT:  (local $parent (ref null $parent))
  ;; CHECK-NEXT:  (local.set $parent
  ;; CHECK-NEXT:   (struct.new $parent
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $parent 0
  ;; CHECK-NEXT:      (local.get $parent)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $parent
  ;; CHECK-NEXT:   (local.tee $child
  ;; CHECK-NEXT:    (struct.new $child
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 30)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $child 0
  ;; CHECK-NEXT:      (local.get $child)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func
    (local $child (ref null $child))
    (local $parent (ref null $parent))
    (local.set $parent
      (struct.new $parent
        (i32.const 10)
      )
    )
    (drop
      (struct.get $parent 0
        (local.get $parent)
      )
    )
    (local.set $parent
      (local.tee $child
        (struct.new $child
          (i32.const 10) ;; This is 10, like above, so we can optimize the get
                         ;; before us.
          (i32.const 30)
        )
      )
    )
    (drop
      (struct.get $child 0
        (local.get $child)
      )
    )
  )
)

;; Arrays get/set
(module
  (type $nothing (array_subtype (mut (ref null any)) data))

  ;; CHECK:      (type $null (array (mut anyref)))
  (type $null (array_subtype (mut (ref null any)) data))

  ;; CHECK:      (type $something (array (mut anyref)))
  (type $something (array_subtype (mut (ref null any)) data))

  (type $something-child (array_subtype (mut (ref null any)) $something))

  ;; CHECK:      (type $none_=>_none (func))

  ;; CHECK:      (type $struct (struct ))
  (type $struct (struct))

  ;; CHECK:      (func $func (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (array.set $null
  ;; CHECK-NEXT:   (array.new_default $null
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (i32.const 0)
  ;; CHECK-NEXT:   (ref.null none)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block (result nullref)
  ;; CHECK-NEXT:      (drop
  ;; CHECK-NEXT:       (array.get $null
  ;; CHECK-NEXT:        (array.new_default $null
  ;; CHECK-NEXT:         (i32.const 10)
  ;; CHECK-NEXT:        )
  ;; CHECK-NEXT:        (i32.const 0)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (ref.null none)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (array.set $something
  ;; CHECK-NEXT:   (array.new_default $something
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (i32.const 0)
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (array.get $something
  ;; CHECK-NEXT:     (array.new_default $something
  ;; CHECK-NEXT:      (i32.const 10)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (block
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func
    ;; Reading from a null will trap, and we can optimize to an unreachable.
    (drop
      (array.get $nothing
        (ref.null $nothing)
        (i32.const 0)
      )
    )
    ;; Write a null to this array.
    (array.set $null
      (array.new_default $null
        (i32.const 10)
      )
      (i32.cons