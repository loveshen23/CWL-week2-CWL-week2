// DO NOT EDIT! This file generated by scripts/gen-s-parser.py

// clang-format off

#ifdef INSTRUCTION_PARSER
#undef INSTRUCTION_PARSER
using namespace std::string_view_literals;
auto op = s[0]->str().str;
char buf[33] = {};
memcpy(buf, op.data(), op.size());
switch (buf[0]) {
  case 'a': {
    switch (buf[1]) {
      case 'r': {
        switch (buf[6]) {
          case 'c':
            if (op == "array.copy"sv) { return makeArrayCopy(s); }
            goto parse_error;
          case 'g': {
            switch (buf[9]) {
              case '\0':
                if (op == "array.get"sv) { return makeArrayGet(s); }
                goto parse_error;
              case '_': {
                switch (buf[10]) {
                  case 's':
                    if (op == "array.get_s"sv) { return makeArrayGet(s, true); }
                    goto parse_error;
                  case 'u':
                    if (op == "array.get_u"sv) { return makeArrayGet(s, false); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              default: goto parse_error;
            }
          }
          case 'i':
            if (op == "array.init_static"sv) { return makeArrayNewFixed(s); }
            goto parse_error;
          case 'l':
            if (op == "array.len"sv) { return makeArrayLen(s); }
            goto parse_error;
          case 'n': {
            switch (buf[9]) {
              case '\0':
                if (op == "array.new"sv) { return makeArrayNew(s, false); }
                goto parse_error;
              case '_': {
                switch (buf[10]) {
                  case 'd': {
                    switch (buf[11]) {
                      case 'a':
                        if (op == "array.new_data"sv) { return makeArrayNewSeg(s, NewData); }
                        goto parse_error;
                      case 'e':
                        if (op == "array.new_default"sv) { return makeArrayNew(s, true); }
                        goto parse_error;
                      default: goto parse_error;
                    }
                  }
                  case 'e':
                    if (op == "array.new_elem"sv) { return makeArrayNewSeg(s, NewElem); }
                    goto parse_error;
                  case 'f':
                    if (op == "array.new_fixed"sv) { return makeArrayNewFixed(s); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              default: goto parse_error;
            }
          }
          case 's':
            if (op == "array.set"sv) { return makeArraySet(s); }
            goto parse_error;
          default: goto parse_error;
        }
      }
      case 't':
        if (op == "atomic.fence"sv) { return makeAtomicFence(s); }
        goto parse_error;
      default: goto parse_error;
    }
  }
  case 'b': {
    switch (buf[1]) {
      case 'l':
        if (op == "block"sv) { return makeBlock(s); }
        goto parse_error;
      case 'r': {
        switch (buf[2]) {
          case '\0':
            if (op == "br"sv) { return makeBreak(s); }
            goto parse_error;
          case '_': {
            switch (buf[3]) {
              case 'i':
                if (op == "br_if"sv) { return makeBreak(s); }
                goto parse_error;
              case 'o': {
                switch (buf[6]) {
                  case 'c': {
                    switch (buf[10]) {
                      case '\0':
                        if (op == "br_on_cast"sv) { return makeBrOnCast(s, std::nullopt); }
                        goto parse_error;
                      case '_': {
                        switch (buf[11]) {
                          case 'f':
                            if (op == "br_on_cast_fail"sv) { return makeBrOnCast(s, std::nullopt, true); }
                            goto parse_error;
                          case 's': {
                            switch (buf[17]) {
                              case '\0':
                                if (op == "br_on_cast_static"sv) { return makeBrOnCast(s, std::nullopt); }
                                goto parse_error;
                              case '_':
                                if (op == "br_on_cast_static_fail"sv) { return makeBrOnCast(s, std::nullopt, true); }
                                goto parse_error;
                              default: goto parse_error;
                            }
                          }
                          default: goto parse_error;
                        }
                      }
                      default: goto parse_error;
                    }
                  }
                  case 'f':
                    if (op == "br_on_func"sv) { return makeBrOnCast(s, Type(HeapType::func, NonNullable)); }
                    goto parse_error;
                  case 'i':
                    if (op == "br_on_i31"sv) { return makeBrOnCast(s, Type(HeapType::i31, NonNullable)); }
                    goto parse_error;
                  case 'n': {
                    switch (buf[7]) {
                      case 'o': {
                        switch (buf[10]) {
                          case 'f':
                            if (op == "br_on_non_func"sv) { return makeBrOnCast(s, Type(HeapType::func, NonNullable), true); }
                            goto parse_error;
                          case 'i':
                            if (op == "br_on_non_i31"sv) { return makeBrOnCast(s, Type(HeapType::i31, NonNullable), true); }
                            goto parse_error;
                          case 'n':
                            if (op == "br_on_non_null"sv) { return makeBrOnNull(s, true); }
                            goto parse_error;
                          default: goto parse_error;
                        }
                      }
                      case 'u':
                        if (op == "br_on_null"sv) { return makeBrOnNull(s); }
                        goto parse_error;
                      default: goto parse_error;
                    }
                  }
                  default: goto parse_error;
                }
              }
              case 't':
                if (op == "br_table"sv) { return makeBreakTable(s); }
                goto parse_error;
              default: goto parse_error;
            }
          }
          default: goto parse_error;
        }
      }
      default: goto parse_error;
    }
  }
  case 'c': {
    switch (buf[4]) {
      case '\0':
        if (op == "call"sv) { return makeCall(s, /*isReturn=*/false); }
        goto parse_error;
      case '_': {
        switch (buf[5]) {
          case 'i':
            if (op == "call_indirect"sv) { return makeCallIndirect(s, /*isReturn=*/false); }
            goto parse_error;
          case 'r':
            if (op == "call_ref"sv) { return makeCallRef(s, /*isReturn=*/false); }
            goto parse_error;
          default: goto parse_error;
        }
      }
      default: goto parse_error;
    }
  }
  case 'd': {
    switch (buf[1]) {
      case 'a':
        if (op == "data.drop"sv) { return makeDataDrop(s); }
        goto parse_error;
      case 'r':
        if (op == "drop"sv) { return makeDrop(s); }
        goto parse_error;
      default: goto parse_error;
    }
  }
  case 'e': {
    switch (buf[1]) {
      case 'l':
        if (op == "else"sv) { return makeThenOrElse(s); }
        goto parse_error;
      case 'x': {
        switch (buf[7]) {
          case 'e':
            if (op == "extern.externalize"sv) { return makeRefAs(s, ExternExternalize); }
            goto parse_error;
          case 'i':
            if (op == "extern.internalize"sv) { return makeRefAs(s, ExternInternalize); }
            goto parse_error;
          default: goto parse_error;
        }
      }
      default: goto parse_error;
    }
  }
  case 'f': {
    switch (buf[1]) {
      case '3': {
        switch (buf[3]) {
          case '.': {
            switch (buf[4]) {
              case 'a': {
                switch (buf[5]) {
                  case 'b':
                    if (op == "f32.abs"sv) { return makeUnary(s, UnaryOp::AbsFloat32); }
                    goto parse_error;
                  case 'd':
                    if (op == "f32.add"sv) { return makeBinary(s, BinaryOp::AddFloat32); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'c': {
                switch (buf[5]) {
                  case 'e':
                    if (op == "f32.ceil"sv) { return makeUnary(s, UnaryOp::CeilFloat32); }
                    goto parse_error;
                  case 'o': {
                    switch (buf[6]) {
                      case 'n': {
                        switch (buf[7]) {
                          case 's':
                            if (op == "f32.const"sv) { return makeConst(s, Type::f32); }
                            goto parse_error;
                          case 'v': {
                            switch (buf[13]) {
                              case '3': {
                                switch (buf[16]) {
                                  case 's':
                                    if (op == "f32.convert_i32_s"sv) { return makeUnary(s, UnaryOp::ConvertSInt32ToFloat32); }
                                    goto parse_error;
                                  case 'u':
                                    if (op == "f32.convert_i32_u"sv) { return makeUnary(s, UnaryOp::ConvertUInt32ToFloat32); }
                                    goto parse_error;
                                  default: goto parse_error;
                                }
                              }
                              case '6': {
                                switch (buf[16]) {
                                  case 's':
                                    if (op == "f32.convert_i64_s"sv) { return makeUnary(s, UnaryOp::ConvertSInt64ToFloat32); }
                                    goto parse_error;
                                  case 'u':
                                    if (op == "f32.convert_i64_u"sv) { return makeUnary(s, UnaryOp::ConvertUInt64ToFloat32); }
                                    goto parse_error;
                                  default: goto parse_error;
                                }
                              }
                              default: goto parse_error;
                            }
                          }
                          default: goto parse_error;
                        }
                      }
                      case 'p':
                        if (op == "f32.copysign"sv) { return makeBinary(s, BinaryOp::CopySignFloat32); }
                        goto parse_error;
                      default: goto parse_error;
                    }
                  }
                  default: goto parse_error;
                }
              }
              case 'd': {
                switch (buf[5]) {
                  case 'e':
                    if (op == "f32.demote_f64"sv) { return makeUnary(s, UnaryOp::DemoteFloat64); }
                    goto parse_error;
                  case 'i':
                    if (op == "f32.div"sv) { return makeBinary(s, BinaryOp::DivFloat32); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'e':
                if (op == "f32.eq"sv) { return makeBinary(s, BinaryOp::EqFloat32); }
                goto parse_error;
              case 'f':
                if (op == "f32.floor"sv) { return makeUnary(s, UnaryOp::FloorFloat32); }
                goto parse_error;
              case 'g': {
                switch (buf[5]) {
                  case 'e':
                    if (op == "f32.ge"sv) { return makeBinary(s, BinaryOp::GeFloat32); }
                    goto parse_error;
                  case 't':
                    if (op == "f32.gt"sv) { return makeBinary(s, BinaryOp::GtFloat32); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'l': {
                switch (buf[5]) {
                  case 'e':
                    if (op == "f32.le"sv) { return makeBinary(s, BinaryOp::LeFloat32); }
                    goto parse_error;
                  case 'o':
                    if (op == "f32.load"sv) { return makeLoad(s, Type::f32, /*signed=*/false, 4, /*isAtomic=*/false); }
                    goto parse_error;
                  case 't':
                    if (op == "f32.lt"sv) { return makeBinary(s, BinaryOp::LtFloat32); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'm': {
                switch (buf[5]) {
                  case 'a':
                    if (op == "f32.max"sv) { return makeBinary(s, BinaryOp::MaxFloat32); }
                    goto parse_error;
                  case 'i':
                    if (op == "f32.min"sv) { return makeBinary(s, BinaryOp::MinFloat32); }
                    goto parse_error;
                  case 'u':
                    if (op == "f32.mul"sv) { return makeBinary(s, BinaryOp::MulFloat32); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'n': {
                switch (buf[6]) {
                  case '\0':
                    if (op == "f32.ne"sv) { return makeBinary(s, BinaryOp::NeFloat32); }
                    goto parse_error;
                  case 'a':
                    if (op == "f32.nearest"sv) { return makeUnary(s, UnaryOp::NearestFloat32); }
                    goto parse_error;
                  case 'g':
                    if (op == "f32.neg"sv) { return makeUnary(s, UnaryOp::NegFloat32); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'r':
                if (op == "f32.reinterpret_i32"sv) { return makeUnary(s, UnaryOp::ReinterpretInt32); }
                goto parse_error;
              case 's': {
                switch (buf[5]) {
                  case 'q':
                    if (op == "f32.sqrt"sv) { return makeUnary(s, UnaryOp::SqrtFloat32); }
                    goto parse_error;
                  case 't':
                    if (op == "f32.store"sv) { return makeStore(s, Type::f32, 4, /*isAtomic=*/false); }
                    goto parse_error;
                  case 'u':
                    if (op == "f32.sub"sv) { return makeBinary(s, BinaryOp::SubFloat32); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 't':
                if (op == "f32.trunc"sv) { return makeUnary(s, UnaryOp::TruncFloat32); }
                goto parse_error;
              default: goto parse_error;
            }
          }
          case 'x': {
            switch (buf[6]) {
              case 'a': {
                switch (buf[7]) {
                  case 'b':
                    if (op == "f32x4.abs"sv) { return makeUnary(s, UnaryOp::AbsVecF32x4); }
                    goto parse_error;
                  case 'd':
                    if (op == "f32x4.add"sv) { return makeBinary(s, BinaryOp::AddVecF32x4); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'c': {
                switch (buf[7]) {
                  case 'e':
                    if (op == "f32x4.ceil"sv) { return makeUnary(s, UnaryOp::CeilVecF32x4); }
                    goto parse_error;
                  case 'o': {
                    switch (buf[20]) {
                      case 's':
                        if (op == "f32x4.convert_i32x4_s"sv) { return makeUnary(s, UnaryOp::ConvertSVecI32x4ToVecF32x4); }
                        goto parse_error;
                      case 'u':
                        if (op == "f32x4.convert_i32x4_u"sv) { return makeUnary(s, UnaryOp::ConvertUVecI32x4ToVecF32x4); }
                        goto parse_error;
                      default: goto parse_error;
                    }
                  }
                  default: goto parse_error;
                }
              }
              case 'd': {
                switch (buf[7]) {
                  case 'e':
                    if (op == "f32x4.demote_f64x2_zero"sv) { return makeUnary(s, UnaryOp::DemoteZeroVecF64x2ToVecF32x4); }
                    goto parse_error;
                  case 'i':
                    if (op == "f32x4.div"sv) { return makeBinary(s, BinaryOp::DivVecF32x4); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'e': {
                switch (buf[7]) {
                  case 'q':
                    if (op == "f32x4.eq"sv) { return makeBinary(s, BinaryOp::EqVecF32x4); }
                    goto parse_error;
                  case 'x':
                    if (op == "f32x4.extract_lane"sv) { return makeSIMDExtract(s, SIMDExtractOp::ExtractLaneVecF32x4, 4); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'f':
                if (op == "f32x4.floor"sv) { return makeUnary(s, UnaryOp::FloorVecF32x4); }
                goto parse_error;
              case 'g': {
                switch (buf[7]) {
                  case 'e':
                    if (op == "f32x4.ge"sv) { return makeBinary(s, BinaryOp::GeVecF32x4); }
                    goto parse_error;
                  case 't':
                    if (op == "f32x4.gt"sv) { return makeBinary(s, BinaryOp::GtVecF32x4); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'l': {
                switch (buf[7]) {
                  case 'e':
                    if (op == "f32x4.le"sv) { return makeBinary(s, BinaryOp::LeVecF32x4); }
                    goto parse_error;
                  case 't':
                    if (op == "f32x4.lt"sv) { return makeBinary(s, BinaryOp::LtVecF32x4); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'm': {
                switch (buf[7]) {
                  case 'a':
                    if (op == "f32x4.max"sv) { return makeBinary(s, BinaryOp::MaxVecF32x4); }
                    goto parse_error;
                  case 'i':
                    if (op == "f32x4.min"sv) { return makeBinary(s, BinaryOp::MinVecF32x4); }
                    goto parse_error;
                  case 'u':
                    if (op == "f32x4.mul"sv) { return makeBinary(s, BinaryOp::MulVecF32x4); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'n': {
                switch (buf[8]) {
                  case '\0':
                    if (op == "f32x4.ne"sv) { return makeBinary(s, BinaryOp::NeVecF32x4); }
                    goto parse_error;
                  case 'a':
                    if (op == "f32x4.nearest"sv) { return makeUnary(s, UnaryOp::NearestVecF32x4); }
                    goto parse_error;
                  case 'g':
                    if (op == "f32x4.neg"sv) { return makeUnary(s, UnaryOp::NegVecF32x4); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'p': {
                switch (buf[8]) {
                  case 'a':
                    if (op == "f32x4.pmax"sv) { return makeBinary(s, BinaryOp::PMaxVecF32x4); }
                    goto parse_error;
                  case 'i':
                    if (op == "f32x4.pmin"sv) { return makeBinary(s, BinaryOp::PMinVecF32x4); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'r': {
                switch (buf[8]) {
                  case 'l': {
                    switch (buf[14]) {
                      case 'f': {
                        switch (buf[16]) {
                          case 'a':
                            if (op == "f32x4.relaxed_fma"sv) { return makeSIMDTernary(s, SIMDTernaryOp::RelaxedFmaVecF32x4); }
                            goto parse_error;
                          case 's':
                            if (op == "f32x4.relaxed_fms"sv) { return makeSIMDTernary(s, SIMDTernaryOp::RelaxedFmsVecF32x4); }
                            goto parse_error;
                          default: goto parse_error;
                        }
                      }
                      case 'm': {
                        switch (buf[15]) {
                          case 'a':
                            if (op == "f32x4.relaxed_max"sv) { return makeBinary(s, BinaryOp::RelaxedMaxVecF32x4); }
                            goto parse_error;
                          case 'i':
                            if (op == "f32x4.relaxed_min"sv) { return makeBinary(s, BinaryOp::RelaxedMinVecF32x4); }
                            goto parse_error;
                          default: goto parse_error;
                        }
                      }
                      default: goto parse_error;
                    }
                  }
                  case 'p':
                    if (op == "f32x4.replace_lane"sv) { return makeSIMDReplace(s, SIMDReplaceOp::ReplaceLaneVecF32x4, 4); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 's': {
                switch (buf[7]) {
                  case 'p':
                    if (op == "f32x4.splat"sv) { return makeUnary(s, UnaryOp::SplatVecF32x4); }
                    goto parse_error;
                  case 'q':
                    if (op == "f32x4.sqrt"sv) { return makeUnary(s, UnaryOp::SqrtVecF32x4); }
                    goto parse_error;
                  case 'u':
                    if (op == "f32x4.sub"sv) { return makeBinary(s, BinaryOp::SubVecF32x4); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 't':
                if (op == "f32x4.trunc"sv) { return makeUnary(s, UnaryOp::TruncVecF32x4); }
                goto parse_error;
              default: goto parse_error;
            }
          }
          default: goto parse_error;
        }
      }
      case '6': {
        switch (buf[3]) {
          case '.': {
            switch (buf[4]) {
              case 'a': {
                switch (buf[5]) {
                  case 'b':
                    if (op == "f64.abs"sv) { return makeUnary(s, UnaryOp::AbsFloat64); }
                    goto parse_error;
                  case 'd':
                    if (op == "f64.add"sv) { return makeBinary(s, BinaryOp::AddFloat64); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'c': {
                switch (buf[5]) {
                  case 'e':
                    if (op == "f64.ceil"sv) { return makeUnary(s, UnaryOp::CeilFloat64); }
                    goto parse_error;
                  case 'o': {
                    switch (buf[6]) {
                      case 'n': {
                        switch (buf[7]) {
                          case 's':
                            if (op == "f64.const"sv) { return makeConst(s, Type::f64); }
                            goto parse_error;
                          case 'v': {
                            switch (buf[13]) {
                              case '3': {
                                switch (buf[16]) {
                                  case 's':
                                    if (op == "f64.convert_i32_s"sv) { return makeUnary(s, UnaryOp::ConvertSInt32ToFloat64); }
                                    goto parse_error;
                                  case 'u':
                                    if (op == "f64.convert_i32_u"sv) { return makeUnary(s, UnaryOp::ConvertUInt32ToFloat64); }
                                    goto parse_error;
                                  default: goto parse_error;
                                }
                              }
                              case '6': {
                                switch (buf[16]) {
                                  case 's':
                                    if (op == "f64.convert_i64_s"sv) { return makeUnary(s, UnaryOp::ConvertSInt64ToFloat64); }
                                    goto parse_error;
                                  case 'u':
                                    if (op == "f64.convert_i64_u"sv) { return makeUnary(s, UnaryOp::ConvertUInt64ToFloat64); }
                                    goto parse_error;
                                  default: goto parse_error;
                                }
                              }
                              default: goto parse_error;
                            }
                          }
                          default: goto parse_error;
                        }
                      }
                      case 'p':
                        if (op == "f64.copysign"sv) { return makeBinary(s, BinaryOp::CopySignFloat64); }
                        goto parse_error;
                      default: goto parse_error;
                    }
                  }
                  default: goto parse_error;
                }
              }
              case 'd':
                if (op == "f64.div"sv) { return makeBinary(s, BinaryOp::DivFloat64); }
                goto parse_error;
              case 'e':
                if (op == "f64.eq"sv) { return makeBinary(s, BinaryOp::EqFloat64); }
                goto parse_error;
              case 'f':
                if (op == "f64.floor"sv) { return makeUnary(s, UnaryOp::FloorFloat64); }
                goto parse_error;
              case 'g': {
                switch (buf[5]) {
                  case 'e':
                    if (op == "f64.ge"sv) { return makeBinary(s, BinaryOp::GeFloat64); }
                    goto parse_error;
                  case 't':
                    if (op == "f64.gt"sv) { return makeBinary(s, BinaryOp::GtFloat64); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'l': {
                switch (buf[5]) {
                  case 'e':
                    if (op == "f64.le"sv) { return makeBinary(s, BinaryOp::LeFloat64); }
                    goto parse_error;
                  case 'o':
                    if (op == "f64.load"sv) { return makeLoad(s, Type::f64, /*signed=*/false, 8, /*isAtomic=*/false); }
                    goto parse_error;
                  case 't':
                    if (op == "f64.lt"sv) { return makeBinary(s, BinaryOp::LtFloat64); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'm': {
                switch (buf[5]) {
                  case 'a':
                    if (op == "f64.max"sv) { return makeBinary(s, BinaryOp::MaxFloat64); }
                    goto parse_error;
                  case 'i':
                    if (op == "f64.min"sv) { return makeBinary(s, BinaryOp::MinFloat64); }
                    goto parse_error;
                  case 'u':
                    if (op == "f64.mul"sv) { return makeBinary(s, BinaryOp::MulFloat64); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'n': {
                switch (buf[6]) {
                  case '\0':
                    if (op == "f64.ne"sv) { return makeBinary(s, BinaryOp::NeFloat64); }
                    goto parse_error;
                  case 'a':
                    if (op == "f64.nearest"sv) { return makeUnary(s, UnaryOp::NearestFloat64); }
                    goto parse_error;
                  case 'g':
                    if (op == "f64.neg"sv) { return makeUnary(s, UnaryOp::NegFloat64); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'p':
                if (op == "f64.promote_f32"sv) { return makeUnary(s, UnaryOp::PromoteFloat32); }
                goto parse_error;
              case 'r':
                if (op == "f64.reinterpret_i64"sv) { return makeUnary(s, UnaryOp::ReinterpretInt64); }
                goto parse_error;
              case 's': {
                switch (buf[5]) {
                  case 'q':
                    if (op == "f64.sqrt"sv) { return makeUnary(s, UnaryOp::SqrtFloat64); }
                    goto parse_error;
                  case 't':
                    if (op == "f64.store"sv) { return makeStore(s, Type::f64, 8, /*isAtomic=*/false); }
                    goto parse_error;
                  case 'u':
                    if (op == "f64.sub"sv) { return makeBinary(s, BinaryOp::SubFloat64); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 't':
                if (op == "f64.trunc"sv) { return makeUnary(s, UnaryOp::TruncFloat64); }
                goto parse_error;
              default: goto parse_error;
            }
          }
          case 'x': {
            switch (buf[6]) {
              case 'a': {
                switch (buf[7]) {
                  case 'b':
                    if (op == "f64x2.abs"sv) { return makeUnary(s, UnaryOp::AbsVecF64x2); }
                    goto parse_error;
                  case 'd':
                    if (op == "f64x2.add"sv) { return makeBinary(s, BinaryOp::AddVecF64x2); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'c': {
                switch (buf[7]) {
                  case 'e':
                    if (op == "f64x2.ceil"sv) { return makeUnary(s, UnaryOp::CeilVecF64x2); }
                    goto parse_error;
                  case 'o': {
                    switch (buf[24]) {
                      case 's':
                        if (op == "f64x2.convert_low_i32x4_s"sv) { return makeUnary(s, UnaryOp::ConvertLowSVecI32x4ToVecF64x2); }
                        goto parse_error;
                      case 'u':
                        if (op == "f64x2.convert_low_i32x4_u"sv) { return makeUnary(s, UnaryOp::ConvertLowUVecI32x4ToVecF64x2); }
                        goto parse_error;
                      default: goto parse_error;
                    }
                  }
                  default: goto parse_error;
                }
              }
              case 'd':
                if (op == "f64x2.div"sv) { return makeBinary(s, BinaryOp::DivVecF64x2); }
                goto parse_error;
              case 'e': {
                switch (buf[7]) {
                  case 'q':
                    if (op == "f64x2.eq"sv) { return makeBinary(s, BinaryOp::EqVecF64x2); }
                    goto parse_error;
                  case 'x':
                    if (op == "f64x2.extract_lane"sv) { return makeSIMDExtract(s, SIMDExtractOp::ExtractLaneVecF64x2, 2); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'f':
                if (op == "f64x2.floor"sv) { return makeUnary(s, UnaryOp::FloorVecF64x2); }
                goto parse_error;
              case 'g': {
                switch (buf[7]) {
                  case 'e':
                    if (op == "f64x2.ge"sv) { return makeBinary(s, BinaryOp::GeVecF64x2); }
                    goto parse_error;
                  case 't':
                    if (op == "f64x2.gt"sv) { return makeBinary(s, BinaryOp::GtVecF64x2); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'l': {
                switch (buf[7]) {
                  case 'e':
                    if (op == "f64x2.le"sv) { return makeBinary(s, BinaryOp::LeVecF64x2); }
                    goto parse_error;
                  case 't':
                    if (op == "f64x2.lt"sv) { return makeBinary(s, BinaryOp::LtVecF64x2); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'm': {
                switch (buf[7]) {
                  case 'a':
                    if (op == "f64x2.max"sv) { return makeBinary(s, BinaryOp::MaxVecF64x2); }
                    goto parse_error;
                  case 'i':
                    if (op == "f64x2.min"sv) { return makeBinary(s, BinaryOp::MinVecF64x2); }
                    goto parse_error;
                  case 'u':
                    if (op == "f64x2.mul"sv) { return makeBinary(s, BinaryOp::MulVecF64x2); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'n': {
                switch (buf[8]) {
                  case '\0':
                    if (op == "f64x2.ne"sv) { return makeBinary(s, BinaryOp::NeVecF64x2); }
                    goto parse_error;
                  case 'a':
                    if (op == "f64x2.nearest"sv) { return makeUnary(s, UnaryOp::NearestVecF64x2); }
                    goto parse_error;
                  case 'g':
                    if (op == "f64x2.neg"sv) { return makeUnary(s, UnaryOp::NegVecF64x2); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'p': {
                switch (buf[7]) {
                  case 'm': {
                    switch (buf[8]) {
                      case 'a':
                        if (op == "f64x2.pmax"sv) { return makeBinary(s, BinaryOp::PMaxVecF64x2); }
                        goto parse_error;
                      case 'i':
                        if (op == "f64x2.pmin"sv) { return makeBinary(s, BinaryOp::PMinVecF64x2); }
                        goto parse_error;
                      default: goto parse_error;
                    }
                  }
                  case 'r':
                    if (op == "f64x2.promote_low_f32x4"sv) { return makeUnary(s, UnaryOp::PromoteLowVecF32x4ToVecF64x2); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'r': {
                switch (buf[8]) {
                  case 'l': {
                    switch (buf[14]) {
                      case 'f': {
                        switch (buf[16]) {
                          case 'a':
                            if (op == "f64x2.relaxed_fma"sv) { return makeSIMDTernary(s, SIMDTernaryOp::RelaxedFmaVecF64x2); }
                            goto parse_error;
                          case 's':
                            if (op == "f64x2.relaxed_fms"sv) { return makeSIMDTernary(s, SIMDTernaryOp::RelaxedFmsVecF64x2); }
                            goto parse_error;
                          default: goto parse_error;
                        }
                      }
                      case 'm': {
                        switch (buf[15]) {
                          case 'a':
                            if (op == "f64x2.relaxed_max"sv) { return makeBinary(s, BinaryOp::RelaxedMaxVecF64x2); }
                            goto parse_error;
                          case 'i':
                            if (op == "f64x2.relaxed_min"sv) { return makeBinary(s, BinaryOp::RelaxedMinVecF64x2); }
                            goto parse_error;
                          default: goto parse_error;
                        }
                      }
                      default: goto parse_error;
                    }
                  }
                  case 'p':
                    if (op == "f64x2.replace_lane"sv) { return makeSIMDReplace(s, SIMDReplaceOp::ReplaceLaneVecF64x2, 2); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 's': {
                switch (buf[7]) {
                  case 'p':
                    if (op == "f64x2.splat"sv) { return makeUnary(s, UnaryOp::SplatVecF64x2); }
                    goto parse_error;
                  case 'q':
                    if (op == "f64x2.sqrt"sv) { return makeUnary(s, UnaryOp::SqrtVecF64x2); }
                    goto parse_error;
                  case 'u':
                    if (op == "f64x2.sub"sv) { return makeBinary(s, BinaryOp::SubVecF64x2); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 't':
                if (op == "f64x2.trunc"sv) { return makeUnary(s, UnaryOp::TruncVecF64x2); }
                goto parse_error;
              default: goto parse_error;
            }
          }
          default: goto parse_error;
        }
      }
      default: goto parse_error;
    }
  }
  case 'g': {
    switch (buf[7]) {
      case 'g':
        if (op == "global.get"sv) { return makeGlobalGet(s); }
        goto parse_error;
      case 's':
        if (op == "global.set"sv) { return makeGlobalSet(s); }
        goto parse_error;
      default: goto parse_error;
    }
  }
  case 'i': {
    switch (buf[1]) {
      case '1': {
        switch (buf[6]) {
          case 'a': {
            switch (buf[7]) {
              case 'b':
                if (op == "i16x8.abs"sv) { return makeUnary(s, UnaryOp::AbsVecI16x8); }
                goto parse_error;
              case 'd': {
                switch (buf[9]) {
                  case '\0':
                    if (op == "i16x8.add"sv) { return makeBinary(s, BinaryOp::AddVecI16x8); }
                    goto parse_error;
                  case '_': {
                    switch (buf[14]) {
                      case 's':
                        if (op == "i16x8.add_sat_s"sv) { return makeBinary(s, BinaryOp::AddSatSVecI16x8); }
                        goto parse_error;
                      case 'u':
                        if (op == "i16x8.add_sat_u"sv) { return makeBinary(s, BinaryOp::AddSatUVecI16x8); }
                        goto parse_error;
                      default: goto parse_error;
                    }
                  }
                  default: goto parse_error;
                }
              }
              case 'l':
                if (op == "i16x8.all_true"sv) { return makeUnary(s, UnaryOp::AllTrueVecI16x8); }
                goto parse_error;
              case 'v':
                if (op == "i16x8.avgr_u"sv) { return makeBinary(s, BinaryOp::AvgrUVecI16x8); }
                goto parse_error;
              default: goto parse_error;
            }
          }
          case 'b':
            if (op == "i16x8.bitmask"sv) { return makeUnary(s, UnaryOp::BitmaskVecI16x8); }
            goto parse_error;
          case 'd':
            if (op == "i16x8.dot_i8x16_i7x16_s"sv) { return makeBinary(s, BinaryOp::DotI8x16I7x16SToVecI16x8); }
            goto parse_error;
          case 'e': {
            switch (buf[7]) {
              case 'q':
                if (op == "i16x8.eq"sv) { return makeBinary(s, BinaryOp::EqVecI16x8); }
                goto parse_error;
              case 'x': {
                switch (buf[9]) {
                  case 'a': {
                    switch (buf[28]) {
                      case 's':
                        if (op == "i16x8.extadd_pairwise_i8x16_s"sv) { return makeUnary(s, UnaryOp::ExtAddPairwiseSVecI8x16ToI16x8); }
                        goto parse_error;
                      case 'u':
                        if (op == "i16x8.extadd_pairwise_i8x16_u"sv) { return makeUnary(s, UnaryOp::ExtAddPairwiseUVecI8x16ToI16x8); }
                        goto parse_error;
                      default: goto parse_error;
                    }
                  }
                  case 'e': {
                    switch (buf[13]) {
                      case 'h': {
                        switch (buf[24]) {
                          case 's':
                            if (op == "i16x8.extend_high_i8x16_s"sv) { return makeUnary(s, UnaryOp::ExtendHighSVecI8x16ToVecI16x8); }
                            goto parse_error;
                          case 'u':
                            if (op == "i16x8.extend_high_i8x16_u"sv) { return makeUnary(s, UnaryOp::ExtendHighUVecI8x16ToVecI16x8); }
                            goto parse_error;
                          default: goto parse_error;
                        }
                      }
                      case 'l': {
                        switch (buf[23]) {
                          case 's':
                            if (op == "i16x8.extend_low_i8x16_s"sv) { return makeUnary(s, UnaryOp::ExtendLowSVecI8x16ToVecI16x8); }
                            goto parse_error;
                          case 'u':
                            if (op == "i16x8.extend_low_i8x16_u"sv) { return makeUnary(s, UnaryOp::ExtendLowUVecI8x16ToVecI16x8); }
                            goto parse_error;
                          default: goto parse_error;
                        }
                      }
                      default: goto parse_error;
                    }
                  }
                  case 'm': {
                    switch (buf[13]) {
                      case 'h': {
                        switch (buf[24]) {
                          case 's':
                            if (op == "i16x8.extmul_high_i8x16_s"sv) { return makeBinary(s, BinaryOp::ExtMulHighSVecI16x8); }
                            goto parse_error;
                          case 'u':
                            if (op == "i16x8.extmul_high_i8x16_u"sv) { return makeBinary(s, BinaryOp::ExtMulHighUVecI16x8); }
                            goto parse_error;
                          default: goto parse_error;
                        }
                      }
                      case 'l': {
                        switch (buf[23]) {
                          case 's':
                            if (op == "i16x8.extmul_low_i8x16_s"sv) { return makeBinary(s, BinaryOp::ExtMulLowSVecI16x8); }
                            goto parse_error;
                          case 'u':
                            if (op == "i16x8.extmul_low_i8x16_u"sv) { return makeBinary(s, BinaryOp::ExtMulLowUVecI16x8); }
                            goto parse_error;
                          default: goto parse_error;
                        }
                      }
                      default: goto parse_error;
                    }
                  }
                  case 'r': {
                    switch (buf[19]) {
                      case 's':
                        if (op == "i16x8.extract_lane_s"sv) { return makeSIMDExtract(s, SIMDExtractOp::ExtractLaneSVecI16x8, 8); }
                        goto parse_error;
                      case 'u':
                        if (op == "i16x8.extract_lane_u"sv) { return makeSIMDExtract(s, SIMDExtractOp::ExtractLaneUVecI16x8, 8); }
                        goto parse_error;
                      default: goto parse_error;
                    }
                  }
                  default: goto parse_error;
                }
              }
              default: goto parse_error;
            }
          }
          case 'g': {
            switch (buf[7]) {
              case 'e': {
                switch (buf[9]) {
                  case 's':
                    if (op == "i16x8.ge_s"sv) { return makeBinary(s, BinaryOp::GeSVecI16x8); }
                    goto parse_error;
                  case 'u':
                    if (op == "i16x8.ge_u"sv) { return makeBinary(s, BinaryOp::GeUVecI16x8); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 't': {
                switch (buf[9]) {
                  case 's':
                    if (op == "i16x8.gt_s"sv) { return makeBinary(s, BinaryOp::GtSVecI16x8); }
                    goto parse_error;
                  case 'u':
                    if (op == "i16x8.gt_u"sv) { return makeBinary(s, BinaryOp::GtUVecI16x8); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              default: goto parse_error;
            }
          }
          case 'l': {
            switch (buf[7]) {
              case 'a':
                if (op == "i16x8.laneselect"sv) { return makeSIMDTernary(s, SIMDTernaryOp::LaneselectI16x8); }
                goto parse_error;
              case 'e': {
                switch (buf[9]) {
                  case 's':
                    if (op == "i16x8.le_s"sv) { return makeBinary(s, BinaryOp::LeSVecI16x8); }
                    goto parse_error;
                  case 'u':
                    if (op == "i16x8.le_u"sv) { return makeBinary(s, BinaryOp::LeUVecI16x8); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 't': {
                switch (buf[9]) {
                  case 's':
                    if (op == "i16x8.lt_s"sv) { return makeBinary(s, BinaryOp::LtSVecI16x8); }
                    goto parse_error;
                  case 'u':
                    if (op == "i16x8.lt_u"sv) { return makeBinary(s, BinaryOp::LtUVecI16x8); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              default: goto parse_error;
            }
          }
          case 'm': {
            switch (buf[7]) {
              case 'a': {
                switch (buf[10]) {
                  case 's':
                    if (op == "i16x8.max_s"sv) { return makeBinary(s, BinaryOp::MaxSVecI16x8); }
                    goto parse_error;
                  case 'u':
                    if (op == "i16x8.max_u"sv) { return makeBinary(s, BinaryOp::MaxUVecI16x8); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'i': {
                switch (buf[10]) {
                  case 's':
                    if (op == "i16x8.min_s"sv) { return makeBinary(s, BinaryOp::MinSVecI16x8); }
                    goto parse_error;
                  case 'u':
                    if (op == "i16x8.min_u"sv) { return makeBinary(s, BinaryOp::MinUVecI16x8); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'u':
                if (op == "i16x8.mul"sv) { return makeBinary(s, BinaryOp::MulVecI16x8); }
                goto parse_error;
              default: goto parse_error;
            }
          }
          case 'n': {
            switch (buf[7]) {
              case 'a': {
                switch (buf[19]) {
                  case 's':
                    if (op == "i16x8.narrow_i32x4_s"sv) { return makeBinary(s, BinaryOp::NarrowSVecI32x4ToVecI16x8); }
                    goto parse_error;
                  case 'u':
                    if (op == "i16x8.narrow_i32x4_u"sv) { return makeBinary(s, BinaryOp::NarrowUVecI32x4ToVecI16x8); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'e': {
                switch (buf[8]) {
                  case '\0':
                    if (op == "i16x8.ne"sv) { return makeBinary(s, BinaryOp::NeVecI16x8); }
                    goto parse_error;
                  case 'g':
                    if (op == "i16x8.neg"sv) { return makeUnary(s, UnaryOp::NegVecI16x8); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              default: goto parse_error;
            }
          }
          case 'q':
            if (op == "i16x8.q15mulr_sat_s"sv) { return makeBinary(s, BinaryOp::Q15MulrSatSVecI16x8); }
            goto parse_error;
          case 'r': {
            switch (buf[8]) {
              case 'l':
                if (op == "i16x8.relaxed_q15mulr_s"sv) { return makeBinary(s, BinaryOp::RelaxedQ15MulrSVecI16x8); }
                goto parse_error;
              case 'p':
                if (op == "i16x8.replace_lane"sv) { return makeSIMDReplace(s, SIMDReplaceOp::ReplaceLaneVecI16x8, 8); }
                goto parse_error;
              default: goto parse_error;
            }
          }
          case 's': {
            switch (buf[7]) {
              case 'h': {
                switch (buf[8]) {
                  case 'l':
                    if (op == "i16x8.shl"sv) { return makeSIMDShift(s, SIMDShiftOp::ShlVecI16x8); }
                    goto parse_error;
                  case 'r': {
                    switch (buf[10]) {
                      case 's':
                        if (op == "i16x8.shr_s"sv) { return makeSIMDShift(s, SIMDShiftOp::ShrSVecI16x8); }
                        goto parse_error;
                      case 'u':
                        if (op == "i16x8.shr_u"sv) { return makeSIMDShift(s, SIMDShiftOp::ShrUVecI16x8); }
                        goto parse_error;
                      default: goto parse_error;
                    }
                  }
                  default: goto parse_error;
                }
              }
              case 'p':
                if (op == "i16x8.splat"sv) { return makeUnary(s, UnaryOp::SplatVecI16x8); }
                goto parse_error;
              case 'u': {
                switch (buf[9]) {
                  case '\0':
                    if (op == "i16x8.sub"sv) { return makeBinary(s, BinaryOp::SubVecI16x8); }
                    goto parse_error;
                  case '_': {
                    switch (buf[14]) {
                      case 's':
                        if (op == "i16x8.sub_sat_s"sv) { return makeBinary(s, BinaryOp::SubSatSVecI16x8); }
                        goto parse_error;
                      case 'u':
                        if (op == "i16x8.sub_sat_u"sv) { return makeBinary(s, BinaryOp::SubSatUVecI16x8); }
                        goto parse_error;
                      default: goto parse_error;
                    }
                  }
                  default: goto parse_error;
                }
              }
              default: goto parse_error;
            }
          }
          default: goto parse_error;
        }
      }
      case '3': {
        switch (buf[2]) {
          case '1': {
            switch (buf[4]) {
              case 'g': {
                switch (buf[8]) {
                  case 's':
                    if (op == "i31.get_s"sv) { return makeI31Get(s, true); }
                    goto parse_error;
                  case 'u':
                    if (op == "i31.get_u"sv) { return makeI31Get(s, false); }
                    goto parse_error;
                  default: goto parse_error;
                }
              }
              case 'n':
                if (op == "i31.new"sv) { return makeI31New(s); }
                goto parse_error;
              default: goto parse_error;
            }
          }
          case '2': {
            switch (buf[3]) {
              case '.': {
                switch (buf[4]) {
                  case 'a': {
                    switch (buf[5]) {
                      case 'd':
                        if (op == "i32.add"sv) { return makeBinary(s, BinaryOp::AddInt32); }
                        goto parse_error;
                      case 'n':
                        if (op == "i32.and"sv) { return makeBinary(s, BinaryOp::AndInt32); }
                        goto parse_error;
                      case 't': {
                        switch (buf[11]) {
                          case 'l': {
                            switch (buf[15]) {
                              case '\0':
                                if (op == "i32.atomic.load"sv) { return makeLoad(s, Type::i32, /*signed=*/false, 4, /*isAtomic=*/true); }
                                goto parse_error;
                              case '1':
                                if (op == "i32.atomic.load16_u"sv) { return makeLoad(s, Type::i32, /*signed=*/false, 2, /*isAtomic=*/true); }
                                goto parse_error;
                              case '8':
                                if (op == "i32.atomic.load8_u"sv) { return makeLoad(s, Type::i32, /*signed=*/false, 1, /*isAtomic=*/true); }
                                goto parse_error;
                              default: goto parse_error;
                            }
                          }
                          case 'r': {
                            switch (buf[14]) {
                              case '.': {
                                switch (buf[15]) {
                                  case 'a': {
                                    switch (buf[16]) {
                                      case 'd':
                                        if (op == "i32.atomic.rmw.add"sv) { return makeAtomicRMW(s, AtomicRMWOp::RMWAdd, Type::i32, 4); }
                                        goto parse_error;
                                      case 'n':
                                        if (op == "i32.atomic.rmw.and"sv) { return makeAtomicRMW(s, AtomicRMWOp::RMWAnd, Type::i32, 4); }
                                        goto parse_error;
                                      default: goto parse_error;
                                    }
                                  }
                                  case 'c':
                                    if (op == "i32.atomic.rmw.cmpxchg"sv) { return makeAtomicCmpxchg(s, Type::i32, 4); }
                                    goto parse_error;
                                  case 'o':
                                    if (op == "i32.atomic.rmw.or"sv) { return makeAtomicRMW(s, AtomicRMWOp::RMWOr, Type::i32, 4); }
                                    goto parse_error;
                                  case 's':
                                    if (op == "i32.atomic.rmw.sub"sv) { return makeAtomicRMW(s, AtomicRMWOp::RMWSub, Type::i32, 4); }
                                    goto parse_error;
                                  case 'x': {
                                    switch (buf[16]) {
                                      case 'c':
                                        if (op == "i32.atomic.rmw.xchg"sv) { return makeAtomicRMW(s, AtomicRMWOp::RMWXchg, Type::i32, 4); }
                                        goto parse_error;
                                      case 'o':
                                        if (op == "i32.atomic.rmw.xor"sv) { return makeAtomicRMW(s, AtomicRMWOp::RMWXor, Type::i32, 4); }
                                        goto parse_error;
                                      default: goto parse_error;
                                    }
                                  }
                                  default: goto parse_error;
                                }
                              }
                              case '1': {
                                switch (buf[17]) {
                                  case 'a': {
                                    switch (buf[18]) {
                                      case 'd':
                                        if (op == "i32.atomic.rmw16.add_u"sv) { return makeAtomicRMW(s, AtomicRMWOp::RMWAdd, Type::i32, 2); }
                                        goto parse_error;
                                      case 'n':
                                        if (op == "i32.atomic.rmw16.and_u"sv) { return makeAtomicRMW(s, AtomicRMWOp::RMWAnd, Type::i32, 2); }
                                        goto parse_error;
                                      default: goto parse_error;
                                    }
                                  }
                                  case 'c':
                                    if (op == "i32.atomic.rmw16.cmpxchg_u"sv) { return makeAtomicCmpxchg(s, Type::i32, 2); }
                                    goto parse_error;
                                  case 'o':
                                    if (op == "i32.atomic.rmw16.or_u"sv) { return makeAtomicRMW(s, AtomicRMWOp::RMWOr, Type::i32, 2); }
                                    goto parse_error;
                                  case 's':
                                    if (op == "i32.atomic.rmw16.sub_u"sv) { return makeAtomicRMW(s, AtomicRMWOp::RMWSub, Type::i32, 2); }
                                    goto parse_error;
                                  case 'x': {
                                    switch (buf[18]) {
                                      case 'c':
                                        if (op == "i32.atomic.rmw16.xchg_u"sv) { return makeAtomicRMW(s, AtomicRMWOp::RMWXchg, Type::i32, 2); }
                                        goto parse_error;
                                      case 'o':
                                        if (op == "i32.atomic.rmw16.xor_u"sv) { return makeAtomicRMW(s, AtomicRMWOp::RMWXor, Type::i32, 2); }
                                        goto parse_error;
                                      default: goto parse_error;
                                    }
                                  }
                                  default: goto parse_error;
                                }
                              }
                              case '8': {
                                switch (buf[16]) {
                                  case 'a': {
                                    switch (buf[17]) {
                                      case 'd':
                                        if (op == "i32.atomic.rmw8.add_u"sv) { return makeAtomicRMW(s, AtomicRMWOp::RMWAdd, Type::i32, 1); }
                                        goto parse_error;
                                      case 'n':
                                        if (op == "i32.atomic.rmw8.and_u"sv) { return makeAtomicRMW(s, AtomicRMWOp::RMWAnd, Type::i32, 1); }
                                        goto parse_error;
                                      default: goto parse_error;
                                    }
                                  }
                                  case 'c':
                                    if (op == "i32.atomic.rmw8.cmpxchg_u"sv) { return makeAtomicCmpxchg(s, Type::i32, 1); }
                                    goto parse_error;
                                  case 'o':
                                    if (op == "i32.atomic.rmw8.or_u"sv) { return makeAtomicRMW(s, AtomicRMWOp::RMWOr, Type::i32, 1); }
                                    goto parse_error;
                                  case 's':
                                    if (op == "i32.atomic.rmw8.sub_u"sv) { return makeAtomicRMW(s, AtomicRMWOp::RMWSub, Type::i32, 1); }
                                    goto parse_error;
                                  case 'x': {
                                    switch (buf[17]) {
                                      case 'c':
                                        if (op == "i32.atomic.rmw8.xchg_u"sv) { return makeAtomicRMW(s, AtomicRMWOp::RMWXchg, Type::i32, 1); }
                                        goto parse_error;
                                      case 'o':
                                        if (op == "i32.atomic.rmw8.xor_u"sv) { return makeAtomicRMW(s, AtomicRMWOp::RMWXor, Type::i32, 1); }
                                        goto parse_error;
                                      default: goto parse_error;
                                    }
                                  }
                                  default: goto parse_error;
                                }
                              }
                              default: goto parse_error;
                            }
                          }
                          case 's': {
                            switch (buf[16]) {
                              case '\0':
                                if (op == "i32.atomic.store"sv) { return makeStore(s, Type::i32, 4, /*isAtomic=*/true); }
                                goto parse_error;
                              case '1':
                                if (op == "i32.atomic.store16"sv) { return makeStore(s, Type::i32, 2, /*isAtomic=*/true); }
                                goto parse_error;
                              case '8':
                                if (op == "i32.atomic.store8"sv) { return makeStore(s, Type::i32, 1, /*isAtomic=*/true); }
                                goto parse_error;
                              default: goto parse_error;
                            }
                          }
                          default: goto parse_error;
                        }
                      }
                      default: goto parse_error;
                    }
                  }
                  case 'c': {
                    switch (buf[5]) {
                      case 'l':
                        if (op == "i32.clz"sv) { return makeUnary(s, UnaryOp::ClzInt32); }
                        goto parse_error;
                      case 'o':
                        if (op == "i32.const"sv) { return makeConst(s, Type::i32); }
                        goto parse_error;
                      case 't':
                        if (op == "i32.ctz"sv) { return makeUnary(s, UnaryOp::CtzInt32); }
                        goto parse_error;
                      default: goto parse_error;
                    }
                  }
                  case 'd': {
                    switch (buf[8]) {
                      case 's':
                        if (op == "i32.div_s"sv) { return makeBinary(s, BinaryOp::DivSInt32); }
                        goto parse_error;
                      case 'u':
                        if (op == "i32.div_u"sv) { return makeBinary(s, BinaryOp::DivUInt32); }
                        goto parse_error;
                      default: goto parse_error;
                    }
                  }
                  case 'e': {
                    switch (buf[5]) {
                      case 'q': {
                        switch (buf[6]) {
                          case '\0':
                            if (op == "i32.eq"sv) { return makeBinary(s, BinaryOp::EqInt32); }
                            goto parse_error;
                          case 'z':
                            if (op == "i32.eqz"sv) { return makeUnary(s, UnaryOp::EqZInt32); }
                            goto parse_error;
                          default: goto parse_error;
                        }
                      }
                      case 'x': {
                        switch (buf[10]) {
                          case '1':
                            if (op == "i32.extend16_s"sv) { return makeUnary(s, UnaryOp::ExtendS16Int32); }
                            goto parse_error;
                          case '8':
                            if (op == "i32.extend8_s"sv) { return makeUnary(s, UnaryOp::ExtendS8Int32); }
                            goto parse_error;
                          default: goto parse_error;
                        }
                      }
                      default: goto parse_error;
                    }
                  }
                  case 'g': {
                    switch (buf[5]) {
                      case 'e': {
                        switch (buf[7]) {
                          case 's':
                            if (op == "i32.ge_s"sv) { return makeBinary(s, BinaryOp::GeSInt32); }
                            goto parse_error;
                          case 'u':
                            if (op == "i32.ge_u"sv) { return makeBinary(s, BinaryOp::GeUInt32); }
                            goto parse_error;
                          default: goto parse_error;
                        }
                      }
                      case 't': {
                        switch (buf[7]) {
                          case 's':
                            if (op == "i32.gt_s"sv) { return makeBinary(s, BinaryOp::GtSInt32); }
                            goto parse_error;
                          case 'u':
                            if (op == "i32.gt_u"sv) { return makeBinary(s, BinaryOp::GtUInt32); }
                            goto parse_error;
                          default: goto parse_error;
                        }
                      }
                      default: goto parse_error;
                    }
                  }
                  case 'l': {
                    switch (buf[5]) {
                      case 'e': {
                        switch (buf[7]) {
                          case 's':
                            if (op == "i32.le_s"sv) { return makeBinary(s, BinaryOp::LeSInt32); }
                            goto parse_error;
                          case 'u':
                            if (op == "i32.le_u"sv) { return makeBinary(s, BinaryOp::LeUInt32); }
                            goto parse_error;
                          default: goto parse_error;
                        }
                      }
                      case 'o': {
                        switch (buf[8]) {
                          case '\0':
                            if (op == "i32.load"sv) { return makeLoad(s, Type::i32, /*signed=*/false, 4, /*isAtomic=*/false); }
                            goto parse_error;
                          case '1': {
                            switch (buf[11]) {
                              case 's':
                                if (op == "i32.load16_s"sv) { return makeLoad(s, Type::i32, /*signed=*/true, 2, /*isAtomic=*/false); }
                                goto parse_error;
                              case 'u':
                                if (op == "i32.load16_u"sv) { return makeLoad(s, Type::i32, /*signed=*/false, 2, /*isAtomic=*/false); }
                                goto parse_error;
                              default: goto parse_error;
                            }
                          }
                          case '8': {
                            switch (buf[10]) {
                              case 's':
                                if (op == "i32.load8_s"sv) { return makeLoad(s, Type::i32, /*signed=*/true, 1, /*isAtomic=*/false); }
                                goto parse_error;
                              case 'u':
                                if (op == "i32.load8_u"sv) { return makeLoad(s, Type::i32, /*signed=*/false, 1, /*isAtomic=*/false); }
                                goto parse_error;
                              default: goto parse_error;
 